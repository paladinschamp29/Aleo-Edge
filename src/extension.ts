
// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import * as vscode from 'vscode';
import { Diagnostic } from 'vscode';
import {subscribeToDocumentChanges} from './common_function';
import generator,{NoteComment} from "./commentcode";


// This method is called when your extension is activated
// Your extension is activated the very first time the command is executed

export function activate(context: vscode.ExtensionContext) {

	console.log('Aleo Edge is now active on the code !');
	const aleoDiagnotics = vscode.languages.createDiagnosticCollection();
	
	
	//Hover Code
	vscode.languages.registerHoverProvider('aleo', {
		provideHover(document, position, token) {
			const range = document.getWordRangeAtPosition(position);
            const word = document.getText(range);
			interface Keywords{
				"mint":string[],
				"address":string[],
				"record":string[],
				"transaction":string[],
				"commitment":string[],
				"group":string[],
				"scalar":string[],
				"program":string[],
				"import":string[],
				"field":string[]
			};
			
			const keyword :Keywords={
				'mint':["When you say mint, do you want to find out more?",'mint_mention'],
				'address':["Addresses are defined to enable compiler-optimized routines for parsing and operating over addresses.These semantics will be accompanied by a standard library in a future sprint.",'https://developer.aleo.org/leo/language#addresses'],
				'record':["A record is a fundamental data structure for encoding user assets and application state",'https://developer.aleo.org/concepts/records','https://developer.aleo.org/concepts/transactions'],
				'transaction':["A transaction is a collection of transitions, and each transition is a state change for some program on the blockchain","https://www.entropy1729.com/aleo-introduction/"],
				'commitment':['The commitment is a unique identifier for records','https://www.entropy1729.com/aleo-introduction/'],
				'group':["The set of affine points on the elliptic curve passed into the Leo compiler forms a group. Leo supports a subgroup of this group, generated by a generator point, as a primitive data type.",'https://developer.aleo.org/leo/language#group-elements'],
				'scalar':["scalar type for scalar field elements of the elliptic curve subgroup. These are unsigned integers below the modulus of the scalar field.","https://developer.aleo.org/leo/language#scalar-elements"],
				'program':["Aleo programs consist of state and functions which can query or mutate that state in some way. ","https://www.entropy1729.com/aleo-introduction/"],
				'import':["You can import dependencies that are downloaded to the imports directory. An import is declared as import {filename}.leo; This will look for imports/{filename}.leo and bring all declarations into the current file scope","https://developer.aleo.org/leo/language#import"],
				'field':["senstive information","https://developer.aleo.org/leo/language#field-elements"],				
			};
			const includekey: keyof Keywords = word as any;
			let content=keyword[includekey];
			if(!content)
			{ 
				content=[word];
			}
		 return {
			
			contents: content
		  };
		}
	  });

	//-------------------------------------------------------------------------------------------------------------------------------------------

	//Add Comment 
	const commentController = vscode.comments.createCommentController('comment-sample', 'Comment API Sample');
	context.subscriptions.push(commentController);
	// A `CommentingRangeProvider` controls where gutter decorations that allow adding comments are shown
	commentController.commentingRangeProvider = {
		provideCommentingRanges: (document: vscode.TextDocument, token: vscode.CancellationToken) => {
			const lineCount = document.lineCount;
			return [new vscode.Range(0, 0, lineCount - 1, 0)];
		}
	};
	function replyNote(reply: vscode.CommentReply) {
		const thread = reply.thread;
		const newComment = new NoteComment(reply.text, vscode.CommentMode.Preview, { name: 'User' }, thread, thread.comments.length ? 'canDelete' : undefined);
		if (thread.contextValue === 'draft') {
			newComment.label = 'pending';
		}

		thread.comments = [...thread.comments, newComment];
	}
	let commandCreateNote=vscode.commands.registerCommand('aleoedge.createNote', (reply: vscode.CommentReply) => {
		replyNote(reply);
	});
	
	let commandReplyNote=vscode.commands.registerCommand('aleoedge.replyNote', (reply: vscode.CommentReply) => {
		replyNote(reply);
	});
	let commandStartDraft=vscode.commands.registerCommand('aleoedge.startDraft', (reply: vscode.CommentReply) => {
		const thread = reply.thread;
		thread.contextValue = 'draft';
		const newComment = new NoteComment(reply.text, vscode.CommentMode.Preview, { name: 'vscode' }, thread);
		newComment.label = 'pending';
		thread.comments = [...thread.comments, newComment];
	});
	let commandFinishDraft =vscode.commands.registerCommand('aleoedge.finishDraft', (reply: vscode.CommentReply) => {
		const thread = reply.thread;

		if (!thread) {
			return;
		}

		thread.contextValue = undefined;
		thread.collapsibleState = vscode.CommentThreadCollapsibleState.Collapsed;
		if (reply.text) {
			const newComment = new NoteComment(reply.text, vscode.CommentMode.Preview, { name: 'vscode' }, thread);
			thread.comments = [...thread.comments, newComment].map(comment => {
				comment.label = undefined;
				return comment;
			});
		}
	});
	let commandDeleteNoteComment = vscode.commands.registerCommand('aleoedge.deleteNoteComment', (comment: NoteComment) => {
		const thread = comment.parent;
		if (!thread) {
			return;
		}

		thread.comments = thread.comments.filter(cmt => (cmt as NoteComment).id !== comment.id);

		if (thread.comments.length === 0) {
			thread.dispose();
		}
	});

	let commandDeleteNote = vscode.commands.registerCommand('aleoedge.deleteNote', (thread: vscode.CommentThread) => {
		thread.dispose();
	});
	let commandCancelsaveNote = vscode.commands.registerCommand('aleoedge.cancelsaveNote', (comment: NoteComment) => {
		if (!comment.parent) {
			return;
		}

		comment.parent.comments = comment.parent.comments.map(cmt => {
			if ((cmt as NoteComment).id === comment.id) {
				cmt.body = (cmt as NoteComment).savedBody;
				cmt.mode = vscode.CommentMode.Preview;
			}

			return cmt;
		});
	});
	let commandSaveNote=vscode.commands.registerCommand('aleoedge.saveNote', (comment: NoteComment) => {
		if (!comment.parent) {
			return;
		}

		comment.parent.comments = comment.parent.comments.map(cmt => {
			if ((cmt as NoteComment).id === comment.id) {
				(cmt as NoteComment).savedBody = cmt.body;
				cmt.mode = vscode.CommentMode.Preview;
			}

			return cmt;
		});
	});
	let commandEditNote=vscode.commands.registerCommand('aleoedge.editNote', (comment: NoteComment) => {
		if (!comment.parent) {
			return;
		}

		comment.parent.comments = comment.parent.comments.map(cmt => {
			if ((cmt as NoteComment).id === comment.id) {
				cmt.mode = vscode.CommentMode.Editing;
			}

			return cmt;
		});
	});
	let commandDispose=vscode.commands.registerCommand('aleoedge.dispose', () => {
		commentController.dispose();
	});

//---------------------------------------------------------------------------------------------------------------------------------------------------

	let commandFormatCode = vscode.commands.registerCommand('aleoedge.formatcode', () => {
	// Get the active text editor
	const editor = vscode.window.activeTextEditor;

	var activeCodeText = editor?.document.getText();
	var activeCodeTextLines = editor?.document.getText()?.split(/\r?\n/);

	vscode.window.showInformationMessage('Formatting all :' + editor?.document.getText()?.split(/\r?\n/)?.length.toString() + 'lines of code..');
	let formattedText="";

		if (editor) {
			const document = editor.document;
			const codeText = document.getText();
			const removeEmptyLines = (str: string) => str.split(/\r?\n/).filter(line => line.trim() !== '').join('\n');
			removeEmptyLines(codeText);
			let importFlag=false;
			for (const line of removeEmptyLines(codeText)?.split(/\r?\n/)) { 
			
				if(line.trim().startsWith("import"))
				{
					importFlag=true;
					formattedText+=line.trim()+ "\n";
					continue;
				}
				if(!line.trim().startsWith("import") && importFlag){
					formattedText+="\n";
					importFlag=false;
			
				}
				if(line.trim().startsWith("\\"))
				{	
					formattedText+=line.trim()+ "\n";
					continue;
				};
				if(line.trim().endsWith(":"))
				{
					formattedText+=line.trim() + "\n";
					continue;
				};
				if(line.trim().startsWith("program"))
				{	
					formattedText+=line.trim()+"\n\n";
					continue;
				};
				
				if(line.trim().startsWith("function") || line.trim().startsWith("record"))
				{	
					importFlag=false;
					formattedText+=line.trim() +"\n";
					continue;
				};
	
				formattedText+="\t"+line.trim() +"\n";
			}
			let invalidRange = new vscode.Range(0, 0, editor.document.lineCount , 0);
			let fullRange =editor.document.validateRange(invalidRange);
			editor.edit(editBuilder => {
				editBuilder.replace(fullRange,formattedText);
			});
		}
	vscode.window.showInformationMessage('Aleo Edge : Code FORMAT Complete..');
	});
	aleoDiagnotics.clear();
	let commandSecureCode = vscode.commands.registerCommand('aleoedge.securecode', () => {
		// The code you place here will be executed every time your command is executed
		// Display a message box to the user
		//Change the below pattern to match anything starting with 'field' or starting with 'aleo'
		let pattern = /(\baleo[0-9a-zA-Z]+)|(\d+field\b)/g;
	
		let m: RegExpExecArray | null;
	 
		let problems = 0;
		let diagnostics: Diagnostic[] = [];
		
		while ((m = pattern.exec(vscode.window.activeTextEditor?.document.getText()!)) && problems < 100) {
			problems++;		
			//const aleoDiagnotics = vscode.languages.createDiagnosticCollection(m[0]);
			//context.subscriptions.push(aleoDiagnotics);
	
			const aleoDiagnotics = vscode.languages.createDiagnosticCollection();
			//context.subscriptions.push(aleoDiagnotics);
			subscribeToDocumentChanges(context, aleoDiagnotics,m[0],2);
		}	
		aleoDiagnotics.clear();

		vscode.window.showInformationMessage('SECURED check completed on the code with 2 rules!');

	});
	aleoDiagnotics.clear();
	let commandCommentCode = vscode.commands.registerCommand('aleoedge.commentcode', () => {
		generator.initInfo();
		vscode.window.showInformationMessage('COMMENTED your code with Header!');

	
});

	let commandLintCode = vscode.commands.registerCommand('aleoedge.lintcode', () => {
		// The code you place here will be executed every time your command is executed
		// Display a message box to the user 
	
		let pattern = /\b[A-Z]{2,}\b/g;
		let m: RegExpExecArray | null;
	
		let problems = 0;
		let diagnostics: Diagnostic[] = [];
		let uniqueProblems=new Array;
		while ((m= pattern.exec(vscode.window.activeTextEditor?.document.getText()!)) && problems < 100) {
			problems++;		
			if(!uniqueProblems.includes(m[0])){
			const aleoDiagnotics = vscode.languages.createDiagnosticCollection();
			// context.subscriptions.push(aleoDiagnotics);
			subscribeToDocumentChanges(context, aleoDiagnotics,m[0],1);
			uniqueProblems.push(m[0]);		
			}
		}	

		//End of Problems Code
		vscode.window.showInformationMessage('LINTED your code with 12 Static rules!');
		
	});

context.subscriptions.push(commandFormatCode);
context.subscriptions.push(commandSecureCode);
context.subscriptions.push(commandLintCode);
context.subscriptions.push(commandCommentCode);
context.subscriptions.push(commandCreateNote);
context.subscriptions.push(commandReplyNote);
context.subscriptions.push(commandStartDraft);
context.subscriptions.push(commandFinishDraft);
context.subscriptions.push(commandDeleteNoteComment);
context.subscriptions.push(commandDeleteNote);
context.subscriptions.push(commandCancelsaveNote);
context.subscriptions.push(commandSaveNote);
context.subscriptions.push(commandDispose);
context.subscriptions.push(commandEditNote);



//Code Completion Code
interface Keywords{
	"address":object[],
	"token":object[]
}

const keyword:Keywords ={"address":[{"suggest":"private","type":"vscode.CompletionItemKind.Keyword"}],
		"token":[{"suggest":"aleo","type":"vscode.CompletionItemKind.Method"},{"suggest":"record","type":"vscode.CompletionItemKind.Keyword"}]
	};

const provider1 = vscode.languages.registerCompletionItemProvider('aleo', {

	provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken, context: vscode.CompletionContext) {

		// a simple completion item which inserts `Hello World!`
		// const simpleCompletion = new vscode.CompletionItem('Hello World!');

		// // a completion item that inserts its text as snippet,
		// // the `insertText`-property is a `SnippetString` which will be
		// // honored by the editor.
		// const snippetCompletion = new vscode.CompletionItem('Good part of the day');
		// snippetCompletion.insertText = new vscode.SnippetString('Good ${1|morning,afternoon,evening|}. It is ${1}, right?');
		// const docs: any = new vscode.MarkdownString("Inserts a snippet that lets you select [link](x.ts).");
		// snippetCompletion.documentation = docs;
		// docs.baseUri = vscode.Uri.parse('http://example.com/a/b/c/');

		// a completion item that can be accepted by a commit character,
		// the `commitCharacters`-property is set which means that the completion will
		// be inserted and then the character will be typed.

		const commitCharacterCompletion = new vscode.CompletionItem("address");
		commitCharacterCompletion.commitCharacters = ['.'];
		commitCharacterCompletion.documentation = new vscode.MarkdownString('Press `.` to get `.`');

		// a completion item that retriggers IntelliSense when being accepted,
		// the `command`-property is set which the editor will execute after 
		// completion has been inserted. Also, the `insertText` is set so that 
		// a space is inserted after `new`
		const commandCompletion = new vscode.CompletionItem('new');
		commandCompletion.kind = vscode.CompletionItemKind.Keyword;
		commandCompletion.insertText = 'new ';
		commandCompletion.command = { command: 'editor.action.triggerSuggest', title: 'Re-trigger completions...' };

		// return all completion items as array
		return [
			commitCharacterCompletion,
			commandCompletion
		];
	}
});
const provider2 = vscode.languages.registerCompletionItemProvider(
	'aleo',
	{
		provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {
			// get all text until the `position` and check if it reads `console.`
			// and if so then complete if `log`, `warn`, and `error`
			const linePrefix = document.lineAt(position).text.substr(0, position.character);
			if (!linePrefix.endsWith("address.")) {
				return undefined;
			}
			return [
				new vscode.CompletionItem("private", vscode.CompletionItemKind.Keyword),
			];
		}
	},
	'.' // triggered whenever a '.' is being typed
);
const provider3 = vscode.languages.registerCompletionItemProvider('aleo', {

	provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken, context: vscode.CompletionContext) {

		// a simple completion item which inserts `Hello World!`
		// const simpleCompletion = new vscode.CompletionItem('Hello World!');

		// // a completion item that inserts its text as snippet,
		// // the `insertText`-property is a `SnippetString` which will be
		// // honored by the editor.
		// const snippetCompletion = new vscode.CompletionItem('Good part of the day');
		// snippetCompletion.insertText = new vscode.SnippetString('Good ${1|morning,afternoon,evening|}. It is ${1}, right?');
		// const docs: any = new vscode.MarkdownString("Inserts a snippet that lets you select [link](x.ts).");
		// snippetCompletion.documentation = docs;
		// docs.baseUri = vscode.Uri.parse('http://example.com/a/b/c/');

		// a completion item that can be accepted by a commit character,
		// the `commitCharacters`-property is set which means that the completion will
		// be inserted and then the character will be typed.

		const commitCharacterCompletion = new vscode.CompletionItem("token");
		commitCharacterCompletion.commitCharacters = ['.'];
		commitCharacterCompletion.documentation = new vscode.MarkdownString('Press `.` to get `.`');

		// a completion item that retriggers IntelliSense when being accepted,
		// the `command`-property is set which the editor will execute after 
		// completion has been inserted. Also, the `insertText` is set so that 
		// a space is inserted after `new`
		const commandCompletion = new vscode.CompletionItem('new');
		commandCompletion.kind = vscode.CompletionItemKind.Keyword;
		commandCompletion.insertText = 'new ';
		commandCompletion.command = { command: 'editor.action.triggerSuggest', title: 'Re-trigger completions...' };

		// return all completion items as array
		return [
			commitCharacterCompletion,
			commandCompletion
		];
	}
});
const provider4 = vscode.languages.registerCompletionItemProvider(
	'aleo',
	{
		provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {
			// get all text until the `position` and check if it reads `console.`
			// and if so then complete if `log`, `warn`, and `error`
			const linePrefix = document.lineAt(position).text.substr(0, position.character);
			if (!linePrefix.endsWith("token.")) {
				return undefined;
			}

			return [
			
				new vscode.CompletionItem("aleo", vscode.CompletionItemKind.Keyword),
				new vscode.CompletionItem("record", vscode.CompletionItemKind.Keyword)
			];
		}
	},
	'.' // triggered whenever a '.' is being typed
);
context.subscriptions.push(provider1, provider2,provider3,provider4);
}


// This method is called when your extension is deactivated
export function deactivate()
 {}

